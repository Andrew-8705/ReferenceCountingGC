# ReferenceCountingGC
# 1. Проект «gc_ptr» – сборщик мусора на основе подсчёта ссылок с использованием умных указателей

**Запланировано**:
Изначально предполагалось создать систему управления памятью, аналогичную std::shared_ptr, но с возможностью интегрировать её в общий механизм сборки мусора. Планировалось иметь фабричную функцию (gc_new) для
создания объектов, автоматически оборачивающих «сырые» указатели в gc_ptr, а также рассматривалась идея глобальной перегрузки оператора new для автоматической обёртки – что оказалось невозможным в силу
стандартных ограничений языка (new должен возвращать void*).

**Сделано**:
- Реализован шаблон gc_ptr с внутренним контрольным блоком (ControlBlock), содержащим указатель и счётчик ссылок.
- Поддержаны основные операции – копирование, перемещение, разыменование, проверка на нулевой указатель.
- Создана функция‑фабрика gc_new для создания объектов с динамическим выделением памяти и автоматической обёрткой в gc_ptr.

**Что ещё можно сделать**:
- Работа с циклическими зависимостями: текущий механизм не решает проблему циклов (например, если два объекта ссылаются друг на друга, их память не освободится). Возможным решением было бы добавить поддержку
слабых указателей (weak pointers) или иной механизм разрыва циклов.
- Потокобезопасность: на данный момент подсчёт ссылок не защищён от гонок; можно рассмотреть использование атомарных счётчиков.
- Интеграция с системой выделения памяти: хотя идея перегрузки глобального new оказалась нереализуемой, можно изучить другие способы автоматизации создания gc_ptr‑объектов, например, через специализированные
- макросы или инструменты трансформации исходного кода (например, ClangPlugin).

# 2. Реализация сборщика мусора из книги Bill Blunden "Memory Management Algorithms and Implementation in C/C++"

В книге описывается система, в которой создаётся свой менеджер памяти (RefCountMemoryManager), реализующий выделение памяти через низкоуровневые функции (HeapAlloc) с встроенным механизмом подсчёта ссылок.
Функции inc() и dec() должны вызываться компилятором при копировании или изменении указателей, чтобы автоматически увеличивать/уменьшать счётчик, а при достижении нуля – освобождать блок

**Сделано**:
- Реализованы функции newMalloc() и newFree() (хотя освобождение памяти в newFree не производится – вместо этого используется сборка мусора).
- Написан класс RefCountMemoryManager с поддержкой разделения памяти на блоки, их разбиения (split) и объединения (merge), а также ручного управления счётчиками ссылок через inc() и dec().
- Предусмотрены тестовый драйвер и тест производительности, демонстрирующие работу менеджера памяти.

**Что ещё можно сделать**:
- Автоматизация вызовов inc()/dec(): в книге автор предполагает, что компилятор будет автоматически вставлять вызовы этих функций, но на практике их приходится вставлять вручную. Можно попробовать реализовать препроцессорные макросы или использовать инструменты трансформации исходного кода для автоматизации этого процесса.
- Обработка циклических ссылок: как и в первом проекте, реализация не защищена от циклических зависимостей – здесь можно подумать о внедрении слабых ссылок или альтернативных механизмов разрушения циклов
